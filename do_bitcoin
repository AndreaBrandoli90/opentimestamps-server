#!/usr/bin/python3
# Copyright (C) 2012 Peter Todd <pete@petertodd.org>
#
# This file is part of the OpenTimestamps Server.
#
# It is subject to the license terms in the LICENSE file found in the top-level
# directory of this distribution and at http://opentimestamps.org
#
# No part of the OpenTimestamps Server, including this file, may be copied,
# modified, propagated, or distributed except according to the terms contained
# in the LICENSE file.

import argparse
import json
import logging
import os
import random
import sys

import otsserver

from opentimestamps._internal import hexlify,unhexlify
from opentimestamps.crypto import sha256
from opentimestamps.dag import Hash,build_merkle_tree,Dag,Op
from opentimestamps.io import TimestampFile
import opentimestamps.client

from otsserver._internal import exclusive_lockf
from otsserver.bitcoin import *

parser = argparse.ArgumentParser(description="OpenTimestamps server.")

parser.add_argument("--version",action="version",version=otsserver.implementation_identifier)
parser.add_argument("-q","--quiet",action="count",
                             help="Be more quiet.")
parser.add_argument("-v","--verbose",action="count",
                             help="Be more verbose. Both -v and -q may be used multiple times.")
parser.add_argument("-c","--config",action="store",default="~/.otsserver/config",
                help="Location of config file. Defaults to: ~/.otsserver/config")
parser.add_argument("-d","--data",action="store",default="~/.otsserver/",
        help="Location to store data in.")
parser.add_argument("--metadata-url", action="store", default="http://localhost:2302",
                             help="URL used for metadata")
parser.add_argument("--log",action="store",default='INFO',
                             help="Set log level")



args = parser.parse_args()
logging.root.setLevel(args.log)

context = opentimestamps.client.Context(args.config)

MIN_TX_AMOUNT = 0.1
TX_FEE = 0.0005
MIN_CONFIRMATIONS = 2
MY_PUB_KEY = context.config['bitcoin-timestamper']['my_pub_key']

args.data = os.path.expanduser(os.path.normpath(args.data))
assert os.path.exists(args.data)

proxy = setup_rpc_proxy(context.config['bitcoin-timestamper']['identity'], context)

def digest2path(digest):
    """Convert a digest to a sharded path name

    Re-hashes for cryptography
    """
    digest = hexlify(sha256(digest + bytes(context.config['bitcoin-timestamper']['shard-nonce'],'utf8')))
    return '{}/calendar/complete/{}/{}'.format(args.data, digest[0:2], digest)

def txid2path(txid, status):
    """Convert a digest to a sharded path name

    Re-hashes for cryptography
    """
    txid = hexlify(txid)
    if status == 'pending':
        return '{}/calendar/{}/{}'.format(args.data, status, txid)
    elif status == 'archive':
        return '{}/calendar/{}/{}/{}'.format(args.data, status, txid[0:2], txid)
    else:
        assert False

def make_shard_directories(path):
    for i in range(0,256):
        os.makedirs('{}/{:02x}'.format(path,i), exist_ok=True)

make_shard_directories('{}/calendar/complete'.format(args.data))
make_shard_directories('{}/calendar/archive'.format(args.data))


# process pending timestamp transactions
for pending in os.listdir('{}/calendar/pending'.format(args.data)):
    pending = unhexlify(pending)
    pending_file = txid2path(pending, 'pending')
    with open(pending_file, 'r+') as pend_fd:
        with exclusive_lockf(pend_fd):
            pend_info = json.load(pend_fd)

            # FIXME: the hard coded vout isn't ideal
            txout_info = proxy.gettxout(hexlify(pending), 0)

            if txout_info['confirmations'] >= MIN_CONFIRMATIONS:
                block_num = proxy.getblockcount() - txout_info['confirmations'] + 1
                block_hash = proxy.getblockhash(block_num)

                digests = [unhexlify(digest) for digest in pend_info['digests']]
                ops = [Op.from_primitives(op) for op in pend_info['ops']]

                # last op is the transaction, second last is the merkle root
                r = find_digest_in_block(ops[-2], unhexlify(block_hash), proxy)
                if not r:
                    logging.warn('{} should have been in block #{} {}, but not found'\
                            .format(hexlify(pending), block_num, block_hash))
                    continue
                (path_to_block, sig) = r

                block_op = path_to_block[-1]

                dag = Dag()
                dag.update(ops)
                dag.update(path_to_block)

                for digest in digests:
                    timestamp_file = digest2path(digest)
                    if os.path.exists(timestamp_file):
                        continue

                    timestamp = TimestampFile(out_fd=open(timestamp_file,'wb'))

                    timestamp.digests['sha256d'] = digest

                    path = dag.path(digest, block_op)
                    if not path:
                        logging.warn('path to block {} not found for digest {}'\
                                .format(hexlify(digest), hexlify(block_hash)))
                        continue

                    timestamp.dag.update(path)
                    timestamp.signatures.add(sig)

                    timestamp.write()

                logging.info('completed txid {}'.format(hexlify(pending)))
                os.rename(pending_file, txid2path(pending, 'archive'))


# timestamp queued digests
with open('{}/calendar/queue'.format(args.data),'r+') as queue_fd:
    with exclusive_lockf(queue_fd):
        digests = list(set([unhexlify(digest.strip()) for digest in queue_fd.readlines()]))
        random.shuffle(digests)

        logging.info('{} digests to sign'.format(len(digests)))
        if not digests:
            sys.exit()

        merkle = build_merkle_tree(digests, algorithm='sha256d')
        merkle_child = merkle[-1]


        # Create the bitcoin transaction

        # Get unspent inputs to use.
        unspent_txs = proxy.listunspent()

        total_amount = 0
        inputs = []
        for unspent_tx in reversed(sorted(unspent_txs, key=lambda tx: tx['confirmations'])):
            # Check if this tx is a still-pending timestamp tx
            if os.path.exists(txid2path(unhexlify(unspent_tx['txid']), 'pending')):
                continue

            # On the other hand, if this input is a multisig, check that it's
            # one of our transactions to get around the fact that our hacked
            # listunspent could be returning tx's that we can't spend, or that
            # an attacker would spend first.
            raw_unspent_tx = proxy.getrawtransaction(unspent_tx['txid'],1)
            if raw_unspent_tx['vout'][0]['scriptPubKey']['type'] == 'multisig':
                if not os.path.exists(txid2path(unhexlify(unspent_tx['txid']), 'archive')):
                    continue

            # Clean up to 10 "dust" transactions, but once unspent_tx is over
            # that limit, wait until we can reach our minimum total in one go
            # before adding more txs
            if len(inputs) >= 10 and total_amount + unspent_tx['amount'] < MIN_TX_AMOUNT + TX_FEE:
                continue

            inputs.append({'txid':unspent_tx['txid'], 'vout':unspent_tx['vout']})
            total_amount += unspent_tx['amount']

            if total_amount >= MIN_TX_AMOUNT + TX_FEE:
                break


        if not inputs or total_amount < MIN_TX_AMOUNT + TX_FEE:
            logging.error('Out of unspent inputs; quitting')
            sys.exit(1)


        digest_pub_key = hexlify(b'\x00' + merkle_child)
        multi_raw_tx = create_checkmultisig_tx(\
                            inputs, 1, float(total_amount) - TX_FEE,
                            (MY_PUB_KEY, digest_pub_key),
                            proxy)
        sign_response = proxy.signrawtransaction(hexlify(multi_raw_tx))
        signed_raw_tx = unhexlify(sign_response['hex'])

        if not sign_response['complete']:
            logging.error('Could not sign transaction: {}'.format(multi_raw_tx))
            sys.exit(1)

        assert merkle_child in signed_raw_tx

        logging.info('signed tx: {}'.format(sign_response['hex']))

        tx_op = Digest(signed_raw_tx, parents=(merkle_child,))

        dag = Dag()
        dag.update(merkle)
        dag.add(tx_op)

        # verify connectivity
        for digest in digests:
            assert dag.path(digest, tx_op)

        if True:
            # send the transaction out
            txid = unhexlify(proxy.sendrawtransaction(hexlify(signed_raw_tx)))

            logging.info('sent tx {}'.format(hexlify(txid)))

            # save all these details to pending
            with open(txid2path(txid, 'pending'), 'w') as pend_fd:
                pend_info = dict(txid=hexlify(txid), vout=0,
                                 digests=[hexlify(digest) for digest in digests],
                                 ops=[op.to_primitives() for op in (tuple(merkle) + (tx_op,))],
                                 signed_raw_tx=sign_response['hex'])
                json.dump(pend_info, pend_fd, indent=4)

            # queue can now be truncated
            queue_fd.truncate(0)
